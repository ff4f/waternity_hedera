datasource db {
  provider = "sqlite"
  url      = "file:./dev.db"
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id          String  @id @default(cuid())
  name        String
  username    String  @unique
  password    String
  accountId   String?
  walletEvm   String?
  role        String
  createdAt   DateTime @default(now())
  wells       Well[]
  memberships WellMembership[]
}

model Well {
  id          String   @id @default(cuid())
  code        String   @unique
  name        String
  location    String
  topicId     String
  tokenId     String?
  operator    User     @relation(fields: [operatorUserId], references: [id])
  operatorUserId String
  createdAt   DateTime @default(now())
  memberships WellMembership[]
  events      HcsEvent[]
  documents   Document[]
  settlements Settlement[]
  tokens      Token[]
  waterQuality WaterQuality[]

  @@index([topicId])
}

model WellMembership {
  id       String @id @default(cuid())
  user     User   @relation(fields: [userId], references: [id])
  userId   String
  well     Well   @relation(fields: [wellId], references: [id])
  wellId   String
  roleName String
  shareBps Int?

  @@unique([userId, wellId, roleName])
}

model HcsEvent {
  id              String      @id @default(cuid())
  well            Well?       @relation(fields: [wellId], references: [id])
  wellId          String?
  type            String
  messageId       String      @unique
  consensusTime   DateTime?
  sequenceNumber  BigInt?
  txId            String?
  payloadJson     String
  hash            String?     // Running hash from mirror node
  createdAt       DateTime    @default(now())
  anchors         Anchor[]
  documents       Document[]
  waterQuality    WaterQuality[]

  @@index([wellId, consensusTime])
  @@index([messageId])
  @@index([consensusTime])
}

model Document {
  id            String    @id @default(cuid())
  well          Well      @relation(fields: [wellId], references: [id])
  wellId        String
  type          String
  cid           String
  hfsFileId     String?
  anchoredEvent HcsEvent? @relation(fields: [anchoredEventId], references: [id])
  anchoredEventId String?
  createdAt     DateTime  @default(now())
}

model Settlement {
  id             String   @id @default(cuid())
  well           Well     @relation(fields: [wellId], references: [id])
  wellId         String
  // Energy settlement fields
  periodStart    DateTime?
  periodEnd      DateTime?
  kwhTotal       Float?
  grossRevenue   Float?
  requestEventId  String?
  approvalEventId String?
  executeEventId  String?
  escrowTxId     String?
  // Water settlement fields
  buyerAccountId   String?
  sellerAccountId  String?
  waterAmount      Float?
  pricePerLiter    Float?
  totalPrice       Float?
  paymentMethod    String?
  transactionId    String?
  // Common fields
  status         String
  createdAt      DateTime @default(now())
  payouts        Payout[]
}

model WaterQuality {
  id                 String   @id @default(cuid())
  wellId             String
  ph                 Float
  turbidity          Float
  tds                Float    // Total Dissolved Solids
  temperature        Float
  chlorine           Float
  bacteria           Float
  compliance         Boolean
  testedBy           String
  certificationBody  String?
  hcsEventId         String?
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  well     Well     @relation(fields: [wellId], references: [id])
  hcsEvent HcsEvent? @relation(fields: [hcsEventId], references: [id])

  @@map("water_quality")
}

model Payout {
  id               String    @id @default(cuid())
  settlement       Settlement @relation(fields: [settlementId], references: [id])
  settlementId     String
  recipientAccount String
  assetType        String
  amount           Float
  tokenId          String?
  txId             String?
  status           String
  createdAt        DateTime  @default(now())

  @@unique([settlementId, recipientAccount, assetType])
}

model Token {
  id              String    @id @default(cuid())
  well            Well      @relation(fields: [wellId], references: [id])
  wellId          String
  tokenId         String    @unique
  type            String
  name            String
  symbol          String
  treasuryAccount String
  decimals        Int
  createdAt       DateTime  @default(now())
}

model Anchor {
  id          String   @id @default(cuid())
  sourceType  String
  sourceId    String
  hcsEvent    HcsEvent @relation(fields: [hcsEventId], references: [id])
  hcsEventId  String
  digestAlgo  String
  digestHex   String
  createdAt   DateTime @default(now())
}

model Idempotency {
  id           String   @id @default(cuid())
  key          String   // UUIDv4 from Idempotency-Key header or messageId from body
  scope        String   // API endpoint scope (route pathname)
  status       String   // "PENDING", "SUCCEEDED", "FAILED"
  requestHash  String?  // SHA256 hash of the request body for conflict detection
  resultHash   String?  // SHA256 hash of the JSON result for SUCCEEDED operations
  result       String?  // Stored response data for idempotent returns
  createdAt    DateTime @default(now())

  @@unique([key, scope])
  @@index([key])
  @@index([createdAt])
}

model MirrorCursor {
  id                  String   @id @default(cuid())
  topicId             String   @unique
  lastConsensusTime   String   // Format: seconds.nanos
  updatedAt           DateTime @updatedAt
  createdAt           DateTime @default(now())

  @@index([topicId])
}